## HMI A

### Contents
1. [What's new?](#whats_new)
2. [Responsive Layouts](#responsive)
3. [Developer Tools](#developer_tools)
4. [Reusability](#reusability)
5. [Server Config](#server)
6. [Project Generator](#project_generator)

<a id="whats_new"></a>

### 1. What's new?

1.14 Presentation key points:
- Compatability & Package Manager
- **Exercise: Context object**
    - Add a simple control to view the axis status
    - Use the axis "Running" symbol for an indicator
- **Exercise: NC Viewer**
    - Drop in control and configure (check property tooltips)
    - Create 'NC' (500) and 'NC-Task1' (501) ADS targets
    - Add second Axis and enable, jog from the HMI

<a id="responsive"></a>

### 2. Responsive Layouts

We frequently advertise TwinCAT HMI as "Responsive". This means that all the components on a page are accessible and appropriately organized regardless of the size, resolution or aspect ratio of the consuming client. TwinCAT HMI has two primary strategies for achieving this goal:

1. **Relative** size and position values:
    - In general, controls should not rely on **static** *position* (Top, Left, Right, Bottom) or *size* (Height, Width) properties. Instead, these properties should be **relative** to the rest of the controls within the layout and control hierarchy.
2. The Grid Control
    - The Grid control provides HMI developers with an easy way to dynamically reorient controls within a layout. It is a container control organized into rows and columns which can automatically wrap content based on minimum/maximum size thresholds.

>TwinCAT HMI has these tools for building responsive layouts, but it is still much easier to statically define all size/position values. This is the default behavior with the drag & drop designer. Responsive layouts require many more design considerations and forethought.

#### Exercise: Fix the Main page of the HMI application so that it is responsive.
Use the Grid control. Refine the column and row definitions to get an appropriate and responsive layout. Change controls with static size and position properties so they are more responsive. If something that needs to be centered must also remain a fixed size, you may need to implement the **transformation "trick"** (e.g. set the position property to 50% and apply a -50% translation).

Tips:
- You may have to use nested containers (grid within a grid?)
- It is helpful to use the document outline when dealing with nested controls

<a id="developer_tools"></a>

### 3. Developer Tools

The LiveView window has a number of useful tools within the 'Developer Tools' dialog (⚙️).

From the 'Elements' tab, you can explore all the markup and style sheets of the page. When a graphical component is not being rendered how we expect, we can modify the markup and stylesheet attributes directly from here.

#### Exercise: Runtime markup generation
Use the element inspector tool to narrow in on a control (for instance, the `TcHmiImage` control on the Main page). Compare this markup with the designer markup in the `Main.content` file. View the control's build output via the Packages directory in the solution root folder (you may have to build the project). Each control has its own inner markup, styling and logic:
```
$(slnDir)\Packages\Beckhoff.TwinCAT.HMI.Controls.14.1.15\runtimes\native1.12-tchmi\TcHmiImage
```
Understand that the final rendered markup is dynamically generated by the framework. Property values (non-default ones, at least) are stored as attributes in the content file. They are pulled out by the framework *at runtime** and passed into each respective control's logic to be processed.
> *After a build, check out the Default.html file...

#### Exercise: Using the developer tools
- Explore the DOM; generated markup and stylesheets
- Make some CSS or layout tweaks and observe the real time changes
- Modify the EventGrid control to customize the button layout
- Make these changes permanent by adding *selectors* and *attributes* to the project CSS file(s)
- Change the event grid header color by modfying the root section (this also changes the default blue to green for other controls)

```css
.TcHmi_Controls_Beckhoff_TcHmiEventGrid-template-type-toggles > div {
    display: none;
}

:root {
    --tchmi-view-loading-spinner-color: #4c6374;
    --tchmi-highlight-color-1: green;
}
```

Another useful test and debug functionality is the `console` tab. We can execute JavScript right from within this window, with all the loaded references and resources from the framework.

- In the console, explore the `TcHmi.` namespace
```js
TcHmi.Server.getCurrentUser()
TcHmi.Symbol.read('Test', TcHmi.SymbolType.Internal)
```
- There may be a few different ways to accomplish the same thing
```js
TcHmi.Symbol.readEx('%i%Test%/i%')
// server must be read asynchronously!
TcHmi.Symbol.readEx2(
    '%s%ADS.PLC1.GVL.bAuto%/s%', 
    (data) => console.log(data)
)
```
- Get a control instance and read some property values
```js
const ctrl = TcHmi.Controls.get('lblMainPage')
ctrl.getText()
ctrl.getTop()
```
- You can change any properties that are not read-only, and the framework will update the DOM. Note the property names and getter/setter method names:
```js
ctrl.setTop(50)
TcHmi.Binding.createEx2('%i%Test%/i%', 'Text', ctrl)
```
Note that we have modified the runtime version. Reloading the content file will restore the previous property value.

<a id="reusability"></a>

### 4. Reusability
As we continue to write more object-oriented PLC code, we can take similar approaches to component modularity from the HMI side as well. We can leverage User Controls to combine and parameterize common HMI controls for reusability.

The developer of our demo application has created a Function Block to handle similarly behaving Cylinders in their PLC. For the HMI, they have appropriately created a user control which captures all the necessary manual operations and indicators. 

*The FBs are stored in an array in the PLC, which may make it easier for us to reference them in the HMI. TwinCAT HMI does support indirect addressing via the same bracket [ ] notation you would use in the PLC... but there caveats!*

#### Exercise: Rework the Manual page to use fewer user control instances.

- Create a combobox control and populate it with a list of indices
- Bind an instance of the Cylinder user control using indirect addressing

Observe the 'function binding' issue with indirect addressing. We can use the bracket notation for **read-only** indicators, but read/write control must be explicitly bound. We can potentially address this by using the `CreateBinding` function, but we will still need to statically define our array indices. To make this truly dynamic, we will have to write some code.

- Our function will be very similar to `CreateBinding`, just with an extra *index* parameter
- Special handling:
    - Parameter types of `Control`, `String`, `Symbol`, and `Number`
    - Parameter of type `Symbol` must be passed by reference

The body will look something like:

```js
// get symbol expression components
const expr = symbol.getExpression();
const tag = expr.getTag();
const content = expr.getContent();

// rebuild symbol expression string with index
const bindStr = `%${tag}%${content}[${index}]%/${tag}%`;

// create binding
TcHmi.Binding.createEx2(bindStr, property, control);
```

Let's try to call our function when the Combobox control's index is changed. If it doesn't work the first time, you may want to add some `console.log` statements to see what's going on.

> When we go to call our function, make sure all of the bindings are appropriately accessible. For instance, the context/owner object seems to be *only scoped to the actions and conditions editor*. Passing a "hard" reference to the control might be the only way.

We can refine this even more by changing the property name parameter to type `ControlPropertyName` and manually adding a `refTo` entry in the function metadata. How do we know to do this? We can reference the `CreateBinding` function's metadata in the `Packages` directory upon building any TcHmi project.

<a id="server"></a>

### 5. Server Config
- Troubleshooting
    - Client and target license utilization
    - Log page for extension and dotnet errors
- Config Export/Import
    - Runtime user management, recipes
    - Important for offline publishing

### 6. Project Generator

The Project Generator has been out for awhile now, and we **could not recommend it more** for getting started. Even if you do not intend to any of the templating, there is a lot to learn from creating and perusing a generated project. This is the best way to get started "on the right foot" and prevent future rework for any TwinCAT HMI project.
- Responsive navigation
- Localization
- Themed resources

#### Exercise: Run the project generator and poke around
> Some changes to the way 1.14 handles dependencies may require you to manually install packages to the offline source ahead of time.
